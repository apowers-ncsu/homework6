[
  {
    "objectID": "homework6.html",
    "href": "homework6.html",
    "title": "homework6",
    "section": "",
    "text": "library(purrr)\nlibrary(httr)\nlibrary(jsonlite)\n\n\nAttaching package: 'jsonlite'\n\n\nThe following object is masked from 'package:purrr':\n\n    flatten\n\nlibrary(tidyr)\nlibrary(lubridate)\n\n\nAttaching package: 'lubridate'\n\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n\n\n\n\n\nThe purpose of the function lapply() is to execute a function across all elements of a list, returning the list. In purrr, the equivalent function is map().\nTo use lapply() to run a correlation evaluation with method of “kendall”, we use this code: lapply(my_list,cor,method=\"kendall\".\npurrr functions like map() use common programming function names, these functions offer helpful-ish shorthand for anonymous functions or subsetting, and they provide simpler ways to ensure the output matches a desired type.\nA side-effect function is one that does not modify the passed object, often a data frame. It can be used in a piped chain of tidyverse calls to do something else while allowing the chain to continue with later actions on the same df.\nEach function has its own temporary environment, within which variables may be defined and referenced, until the function completes and the environment is destroyed. Also, a variable named sd is not going to conflict with a function call using sd().\n\n\n\n\n\n\nI will write a function getRMSE() that takes a vector of responses and a vector of predictions, returning the RMSE.\n\n\n#####\n#Function getRMSE() - calculate RMSE for vector inputs.\n#Inputs: \n#  vector of responses\n#  vector of predictions\n#  additional arguments for `mean()` function via `...`\n#Outputs: \n#  RMSE\n#Assumptions: None\n#Validation: None\n#####\n\ngetRMSE &lt;- function(responses, predictions, ...) {\n  \n  #find squared diff (error) between response and predictions\n  errors_list &lt;- map2(responses, predictions, \\(x,y) (x - y)^2 )\n  \n  #unlist the result\n  errors &lt;- unlist(errors_list)\n  \n  #find mean of errors and include ellipses\n  mean_error &lt;- mean(errors,...)\n  \n  #find sq root of mean error\n  rmse &lt;- sqrt(mean_error)\n\n  #return it\n  return(rmse)\n  \n}\n\n\n\n\nCompile some values using the code provided. Test the function. Then repeat after replacing two response values with NA_real_, both with and without the additional argument to handle these.\n\n#provided code for test values\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n#call function\ngetRMSE(resp,pred)\n\n[1] 0.9581677\n\n\n\n#replace two responses with NA\nresp[1:2] &lt;- c(NA_real_,NA_real_)\n\n#test once without NA handling\ngetRMSE(resp,pred)\n\n[1] NA\n\n#then again with NA handling in call\ngetRMSE(resp,pred,na.rm=TRUE)\n\n[1] 0.9661699\n\n\n\n\n\nWrite a function for MAE using similar specifications as getRMSE().\n\n\n#####\n#Function getMAE() - calculate MAE for vector inputs.\n#Inputs: \n#  vector of responses\n#  vector of predictions\n#  additional arguments for `mean()` function via `...`\n#Outputs: \n#  MAE\n#Assumptions: None\n#Validation: None\n#####\n\ngetMAE &lt;- function(responses, predictions, ...) {\n  \n  #find abs diff (absolute error) between response and predictions\n  abs_errors_list &lt;- map2(responses, predictions, \\(x,y) abs(x-y))\n  \n  #unlist the result\n  abs_errors &lt;- unlist(abs_errors_list)\n  \n  #find mean of errors and include ellipses\n  mae &lt;- mean(abs_errors,...)\n  \n  #return it\n  return(mae)\n  \n}\n\n\n\n\nCompile some values using the code provided. Test the function. Then repeat after replacing two response values with NA_real_, both with and without the additional argument to handle these.\n\n#provided code for test values\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n#call function\ngetMAE(resp,pred)\n\n[1] 0.8155776\n\n\n\n#replace two responses with NA\nresp[1:2] &lt;- c(NA_real_,NA_real_)\n\n#test once without NA handling\ngetMAE(resp,pred)\n\n[1] NA\n\n#then again with NA handling in call\ngetMAE(resp,pred,na.rm=TRUE)\n\n[1] 0.8241201\n\n\n\n\n\nThis function should get either metric or both, by calling the appropriate helper functions previously defined. Returned values should have appropriate names.\nIt must check that two numeric (atomic) vectors were passed, else print an error and exit.\nBy default, the function should return both metrics and include names. Adding a character string of metrics to find should facilitate a change in behavior.\n\n#####\n#Function getErrorMetrics() - calculate RMSE and/or MAE for vector inputs.\n#Inputs: \n#  vector of responses\n#  vector of predictions\n#  optional metricList character string to identify desired metrics\n#  additional arguments for `mean()` function via `...`\n#Outputs: \n#  RMSE and/or MAE\n#Assumptions: None\n#Validation: Will error gracefully with message if non-atomic vectors are passed.\n#####\n\ngetErrorMetrics &lt;- function(responses, predictions, metricList=NULL, ...) {\n  \n  #error checking - if any of these fail, give message and exit\n  if (!(is.vector(responses)\n        & is.vector(predictions)\n        & is.atomic(responses)\n        & is.atomic(predictions)\n        & is.numeric(responses)\n        & is.numeric(predictions)\n        )\n      )\n    stop(\"Invalid argument type\")\n  \n  #calculate both metrics\n  rmse &lt;- getRMSE(responses,predictions,...)\n  mae &lt;- getMAE(responses,predictions,...)\n  \n  #identify needed values\n  result&lt;-NULL\n  if(is.null(metricList)) \n    result &lt;- c(\"RMSE\" = rmse, \"MAE\" = mae)\n  else {\n    if(\"rmse\" %in% metricList)\n      result &lt;- c(result,\"RMSE\" = rmse)\n    if(\"mae\" %in% metricList)\n      result &lt;- c(result,\"MAE\" = mae)\n  }\n\n  return(result)\n\n}\n\n\n\n\nCompile some values using the code provided. Test the function, asking for each metric individually and once with both.\n\n#provided code for test values\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n#call function without args\ngetErrorMetrics(resp,pred)\n\n     RMSE       MAE \n0.9581677 0.8155776 \n\n#call with each metric individually, then together\ngetErrorMetrics(resp,pred,\"mae\")\n\n      MAE \n0.8155776 \n\ngetErrorMetrics(resp,pred,\"rmse\")\n\n     RMSE \n0.9581677 \n\ngetErrorMetrics(resp,pred,c(\"mae\",\"rmse\"))\n\n     RMSE       MAE \n0.9581677 0.8155776 \n\n\nThen repeat after replacing two response values with NA_real_, first without the special argument to handle these.\n\n#replace two responses with NA\nresp[1:2] &lt;- c(NA_real_,NA_real_)\n\n#call function without args\ngetErrorMetrics(resp,pred)\n\nRMSE  MAE \n  NA   NA \n\n#call with each metric individually, then together\ngetErrorMetrics(resp,pred,\"mae\")\n\nMAE \n NA \n\ngetErrorMetrics(resp,pred,\"rmse\")\n\nRMSE \n  NA \n\ngetErrorMetrics(resp,pred,c(\"mae\",\"rmse\"))\n\nRMSE  MAE \n  NA   NA \n\n\nAgain, now adding the NA-handling argument.\n\n#call function without args\ngetErrorMetrics(resp,pred,na.rm=TRUE)\n\n     RMSE       MAE \n0.9661699 0.8241201 \n\n#call with each metric individually, then together\ngetErrorMetrics(resp,pred,\"mae\",na.rm=TRUE)\n\n      MAE \n0.8241201 \n\ngetErrorMetrics(resp,pred,\"rmse\",na.rm=TRUE)\n\n     RMSE \n0.9661699 \n\ngetErrorMetrics(resp,pred,c(\"mae\",\"rmse\"),na.rm=TRUE)\n\n     RMSE       MAE \n0.9661699 0.8241201 \n\n\nFinally, pass it invalid data like a data frame to show it errors properly.\n\n#getErrorMetrics(as.data.frame(resp),pred)\n\nResult is as follows, which I must comment out to render fully and run my quarto doc.\nError in getErrorMetrics(as.data.frame(resp), pred) : Invalid argument type\n\n\n\n\nMy API key is: 00cc83504de747bbb211235233c86424\n\n\nFind a topic of interest and retrieve information on it. Arbitrarily, I’ll query for articles on NC candidate Mark Robinson.\n\nrawResults &lt;- GET(\"https://newsapi.org/v2/everything?q=mark+robinson&from=2024-10-01&sortBy=popularity&apiKey=00cc83504de747bbb211235233c86424\")\n\n\n\n\nUsing the methods from Project 1, extract the content and use purrr::pluck() to get the articles element. First column should be a list column.\n\n  #pull content JSON branch and convert to char\n  parsed_results &lt;- fromJSON(rawToChar(rawResults$content))\n\n  #grab the articles element\n  articles &lt;- pluck(parsed_results,\"articles\")\n\n\n\n\nNow, I’ll build a quick function to make this repeatable.\n\n#####\n#Function queryNewsAPI() - facilitate queries to the News API of newsapi.org\n#Inputs: \n#  subject (string, spaces replaced by +)\n#  startDate (string in format yyyy-mm-dd, within last 30 days)\n#  apiKey\n#Outputs: \n#  Will parse content from raw to char, parse JSON, pluck the 'articles' element and return it\n#Assumptions: None\n#Validation: None\n#####\n\nqueryNewsAPI &lt;- function(subject, startDate, apiKey) {\n  \n  # Sample URL format\n  # https://newsapi.org/v2/everything?q=\n  # TOPIC\n  # &from=\n  # STARTDATE\n  # &sortBy=popularity&apiKey=\n  # APIKEY\n  \n  url1 &lt;- \"https://newsapi.org/v2/everything?q=\"\n  url2 &lt;- subject\n  url3 &lt;- \"&from=\"\n  url4 &lt;- startDate\n  url5 &lt;- \"&sortBy=popularity&apiKey=\"\n  url6 &lt;- apiKey\n  \n  url &lt;- paste(url1,\n               url2,\n               url3,\n               url4,\n               url5,\n               url6,\n               sep=\"\")\n\n  #pull the url, raw to char, parse json, grab articles element\n  rawResults &lt;- GET(url)\n  charResults &lt;- rawToChar(rawResults$content)\n  data &lt;- \n    charResults |&gt;\n    fromJSON() |&gt;\n    pluck(\"articles\")\n  \n  return(data)\n    \n}\n\nCalling it twice to collect some data. First on Mark Robinson, then on Wilmington NC.\n\ndata1 &lt;- queryNewsAPI('mark+robinson','2024-10-08','00cc83504de747bbb211235233c86424')\ndata2 &lt;- queryNewsAPI('wilmington+nc','2024-10-08','00cc83504de747bbb211235233c86424')\n\n\n\n\nHere, we want a one-way contingency table (counts) of the name of the source for each article. This is easy with the table() function used in HW5.\n\ntable(data1$source$name)\n\n\n                [Removed]            Aftonbladet.se        Al Jazeera English \n                        8                         1                         1 \n                 BBC News           Bleacher Report        Bleeding Cool News \n                        1                         1                         2 \n            Boston Herald            Breitbart News    CBM (Comic Book Movie) \n                        2                         1                         1 \n               CBS Sports               Cineblog.it              CounterPunch \n                       19                         2                         1 \n              Cracked.com                  Deadline          Dianeravitch.net \n                        1                         2                         2 \n                Dnyuz.com         Durham Herald Sun                     Eater \n                        1                         1                         1 \n                     ESPN              Fast Company                    Forbes \n                        5                         1                         6 \n               Fox Sports                  GameSpot                 Ifanr.com \n                        2                         1                         1 \n               Lithub.com                  Mediaite           Memeorandum.com \n                        1                         2                         2 \n             MMA Fighting                 MMA Mania                     MSNBC \n                        1                         3                         2 \n            NBCSports.com Nbcsportsphiladelphia.com                  Newsweek \n                        3                         1                         3 \n            Observador.pt         Politicalwire.com                 Raw Story \n                        1                         1                         2 \n                SB Nation               Screen Rant              Stanford.edu \n                        1                         3                         1 \n             The Atlantic                   TheWrap                      Time \n                        1                         1                         1 \n                 Truthout              Wonkette.com       Worldsoccertalk.com \n                        1                         1                         1 \n      Yahoo Entertainment \n                        3 \n\n\n\n\n\nFor both data objects, change publishedAt column into a date column via lubridate.\nThen sort the data frames by their new parsed date column.\nFinally, create a new column pub_diff via lag() and mutate() that is the difference between publish dates. Save the modified versions as new data frames.\n\nnewdata1 &lt;- \n  data1 |&gt;\n  mutate(publishedAt = ymd_hms(publishedAt)) |&gt;\n  arrange(publishedAt) |&gt;\n  mutate(pub_diff = publishedAt - dplyr::lag(publishedAt,1)) |&gt;\n  as.data.frame()\n\nnewdata2 &lt;- \n  data2 |&gt;\n  mutate(publishedAt = ymd_hms(publishedAt)) |&gt;\n  arrange(publishedAt) |&gt;\n  mutate(pub_diff = publishedAt - dplyr::lag(publishedAt,1)) |&gt;\n  as.data.frame()\n\n\n\n\nChoose one df, subset to return only date version of publishedAt and pub_diff.\nCall map() for mean, sd, median of the columns. Use an anonymous function. Note that pub_diff will have NA so ensure we add na.rm=TRUE in calls.\n\nfinaldata &lt;-\n  newdata2[c(\"publishedAt\",\"pub_diff\")] |&gt;\n  map(\\(x) \n    paste(\"mean:\",\n          mean(x,na.rm=TRUE),\n          \"sd:\",\n          sd(x,na.rm=TRUE),\n          \"median:\",\n          median(x,na.rm=TRUE)))\n   \nfinaldata \n\n$publishedAt\n[1] \"mean: 2024-10-10 14:35:10.625 sd: 201929.864707624 median: 2024-10-10 07:03:28.5\"\n\n$pub_diff\n[1] \"mean: 1333.22619047619 sd: 1105.48763992358 median: 1607.71666666667\""
  },
  {
    "objectID": "homework6.html#r-package-loads",
    "href": "homework6.html#r-package-loads",
    "title": "homework6",
    "section": "",
    "text": "library(purrr)\nlibrary(httr)\nlibrary(jsonlite)\n\n\nAttaching package: 'jsonlite'\n\n\nThe following object is masked from 'package:purrr':\n\n    flatten\n\nlibrary(tidyr)\nlibrary(lubridate)\n\n\nAttaching package: 'lubridate'\n\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union"
  },
  {
    "objectID": "homework6.html#task-1-conceptual-questions",
    "href": "homework6.html#task-1-conceptual-questions",
    "title": "homework6",
    "section": "",
    "text": "The purpose of the function lapply() is to execute a function across all elements of a list, returning the list. In purrr, the equivalent function is map().\nTo use lapply() to run a correlation evaluation with method of “kendall”, we use this code: lapply(my_list,cor,method=\"kendall\".\npurrr functions like map() use common programming function names, these functions offer helpful-ish shorthand for anonymous functions or subsetting, and they provide simpler ways to ensure the output matches a desired type.\nA side-effect function is one that does not modify the passed object, often a data frame. It can be used in a piped chain of tidyverse calls to do something else while allowing the chain to continue with later actions on the same df.\nEach function has its own temporary environment, within which variables may be defined and referenced, until the function completes and the environment is destroyed. Also, a variable named sd is not going to conflict with a function call using sd()."
  },
  {
    "objectID": "homework6.html#task-2-writing-r-functions",
    "href": "homework6.html#task-2-writing-r-functions",
    "title": "homework6",
    "section": "",
    "text": "I will write a function getRMSE() that takes a vector of responses and a vector of predictions, returning the RMSE.\n\n\n#####\n#Function getRMSE() - calculate RMSE for vector inputs.\n#Inputs: \n#  vector of responses\n#  vector of predictions\n#  additional arguments for `mean()` function via `...`\n#Outputs: \n#  RMSE\n#Assumptions: None\n#Validation: None\n#####\n\ngetRMSE &lt;- function(responses, predictions, ...) {\n  \n  #find squared diff (error) between response and predictions\n  errors_list &lt;- map2(responses, predictions, \\(x,y) (x - y)^2 )\n  \n  #unlist the result\n  errors &lt;- unlist(errors_list)\n  \n  #find mean of errors and include ellipses\n  mean_error &lt;- mean(errors,...)\n  \n  #find sq root of mean error\n  rmse &lt;- sqrt(mean_error)\n\n  #return it\n  return(rmse)\n  \n}\n\n\n\n\nCompile some values using the code provided. Test the function. Then repeat after replacing two response values with NA_real_, both with and without the additional argument to handle these.\n\n#provided code for test values\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n#call function\ngetRMSE(resp,pred)\n\n[1] 0.9581677\n\n\n\n#replace two responses with NA\nresp[1:2] &lt;- c(NA_real_,NA_real_)\n\n#test once without NA handling\ngetRMSE(resp,pred)\n\n[1] NA\n\n#then again with NA handling in call\ngetRMSE(resp,pred,na.rm=TRUE)\n\n[1] 0.9661699\n\n\n\n\n\nWrite a function for MAE using similar specifications as getRMSE().\n\n\n#####\n#Function getMAE() - calculate MAE for vector inputs.\n#Inputs: \n#  vector of responses\n#  vector of predictions\n#  additional arguments for `mean()` function via `...`\n#Outputs: \n#  MAE\n#Assumptions: None\n#Validation: None\n#####\n\ngetMAE &lt;- function(responses, predictions, ...) {\n  \n  #find abs diff (absolute error) between response and predictions\n  abs_errors_list &lt;- map2(responses, predictions, \\(x,y) abs(x-y))\n  \n  #unlist the result\n  abs_errors &lt;- unlist(abs_errors_list)\n  \n  #find mean of errors and include ellipses\n  mae &lt;- mean(abs_errors,...)\n  \n  #return it\n  return(mae)\n  \n}\n\n\n\n\nCompile some values using the code provided. Test the function. Then repeat after replacing two response values with NA_real_, both with and without the additional argument to handle these.\n\n#provided code for test values\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n#call function\ngetMAE(resp,pred)\n\n[1] 0.8155776\n\n\n\n#replace two responses with NA\nresp[1:2] &lt;- c(NA_real_,NA_real_)\n\n#test once without NA handling\ngetMAE(resp,pred)\n\n[1] NA\n\n#then again with NA handling in call\ngetMAE(resp,pred,na.rm=TRUE)\n\n[1] 0.8241201\n\n\n\n\n\nThis function should get either metric or both, by calling the appropriate helper functions previously defined. Returned values should have appropriate names.\nIt must check that two numeric (atomic) vectors were passed, else print an error and exit.\nBy default, the function should return both metrics and include names. Adding a character string of metrics to find should facilitate a change in behavior.\n\n#####\n#Function getErrorMetrics() - calculate RMSE and/or MAE for vector inputs.\n#Inputs: \n#  vector of responses\n#  vector of predictions\n#  optional metricList character string to identify desired metrics\n#  additional arguments for `mean()` function via `...`\n#Outputs: \n#  RMSE and/or MAE\n#Assumptions: None\n#Validation: Will error gracefully with message if non-atomic vectors are passed.\n#####\n\ngetErrorMetrics &lt;- function(responses, predictions, metricList=NULL, ...) {\n  \n  #error checking - if any of these fail, give message and exit\n  if (!(is.vector(responses)\n        & is.vector(predictions)\n        & is.atomic(responses)\n        & is.atomic(predictions)\n        & is.numeric(responses)\n        & is.numeric(predictions)\n        )\n      )\n    stop(\"Invalid argument type\")\n  \n  #calculate both metrics\n  rmse &lt;- getRMSE(responses,predictions,...)\n  mae &lt;- getMAE(responses,predictions,...)\n  \n  #identify needed values\n  result&lt;-NULL\n  if(is.null(metricList)) \n    result &lt;- c(\"RMSE\" = rmse, \"MAE\" = mae)\n  else {\n    if(\"rmse\" %in% metricList)\n      result &lt;- c(result,\"RMSE\" = rmse)\n    if(\"mae\" %in% metricList)\n      result &lt;- c(result,\"MAE\" = mae)\n  }\n\n  return(result)\n\n}\n\n\n\n\nCompile some values using the code provided. Test the function, asking for each metric individually and once with both.\n\n#provided code for test values\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n#call function without args\ngetErrorMetrics(resp,pred)\n\n     RMSE       MAE \n0.9581677 0.8155776 \n\n#call with each metric individually, then together\ngetErrorMetrics(resp,pred,\"mae\")\n\n      MAE \n0.8155776 \n\ngetErrorMetrics(resp,pred,\"rmse\")\n\n     RMSE \n0.9581677 \n\ngetErrorMetrics(resp,pred,c(\"mae\",\"rmse\"))\n\n     RMSE       MAE \n0.9581677 0.8155776 \n\n\nThen repeat after replacing two response values with NA_real_, first without the special argument to handle these.\n\n#replace two responses with NA\nresp[1:2] &lt;- c(NA_real_,NA_real_)\n\n#call function without args\ngetErrorMetrics(resp,pred)\n\nRMSE  MAE \n  NA   NA \n\n#call with each metric individually, then together\ngetErrorMetrics(resp,pred,\"mae\")\n\nMAE \n NA \n\ngetErrorMetrics(resp,pred,\"rmse\")\n\nRMSE \n  NA \n\ngetErrorMetrics(resp,pred,c(\"mae\",\"rmse\"))\n\nRMSE  MAE \n  NA   NA \n\n\nAgain, now adding the NA-handling argument.\n\n#call function without args\ngetErrorMetrics(resp,pred,na.rm=TRUE)\n\n     RMSE       MAE \n0.9661699 0.8241201 \n\n#call with each metric individually, then together\ngetErrorMetrics(resp,pred,\"mae\",na.rm=TRUE)\n\n      MAE \n0.8241201 \n\ngetErrorMetrics(resp,pred,\"rmse\",na.rm=TRUE)\n\n     RMSE \n0.9661699 \n\ngetErrorMetrics(resp,pred,c(\"mae\",\"rmse\"),na.rm=TRUE)\n\n     RMSE       MAE \n0.9661699 0.8241201 \n\n\nFinally, pass it invalid data like a data frame to show it errors properly.\n\n#getErrorMetrics(as.data.frame(resp),pred)\n\nResult is as follows, which I must comment out to render fully and run my quarto doc.\nError in getErrorMetrics(as.data.frame(resp), pred) : Invalid argument type"
  },
  {
    "objectID": "homework6.html#task-3-query-api-and-tidy-style-function",
    "href": "homework6.html#task-3-query-api-and-tidy-style-function",
    "title": "homework6",
    "section": "",
    "text": "My API key is: 00cc83504de747bbb211235233c86424\n\n\nFind a topic of interest and retrieve information on it. Arbitrarily, I’ll query for articles on NC candidate Mark Robinson.\n\nrawResults &lt;- GET(\"https://newsapi.org/v2/everything?q=mark+robinson&from=2024-10-01&sortBy=popularity&apiKey=00cc83504de747bbb211235233c86424\")\n\n\n\n\nUsing the methods from Project 1, extract the content and use purrr::pluck() to get the articles element. First column should be a list column.\n\n  #pull content JSON branch and convert to char\n  parsed_results &lt;- fromJSON(rawToChar(rawResults$content))\n\n  #grab the articles element\n  articles &lt;- pluck(parsed_results,\"articles\")\n\n\n\n\nNow, I’ll build a quick function to make this repeatable.\n\n#####\n#Function queryNewsAPI() - facilitate queries to the News API of newsapi.org\n#Inputs: \n#  subject (string, spaces replaced by +)\n#  startDate (string in format yyyy-mm-dd, within last 30 days)\n#  apiKey\n#Outputs: \n#  Will parse content from raw to char, parse JSON, pluck the 'articles' element and return it\n#Assumptions: None\n#Validation: None\n#####\n\nqueryNewsAPI &lt;- function(subject, startDate, apiKey) {\n  \n  # Sample URL format\n  # https://newsapi.org/v2/everything?q=\n  # TOPIC\n  # &from=\n  # STARTDATE\n  # &sortBy=popularity&apiKey=\n  # APIKEY\n  \n  url1 &lt;- \"https://newsapi.org/v2/everything?q=\"\n  url2 &lt;- subject\n  url3 &lt;- \"&from=\"\n  url4 &lt;- startDate\n  url5 &lt;- \"&sortBy=popularity&apiKey=\"\n  url6 &lt;- apiKey\n  \n  url &lt;- paste(url1,\n               url2,\n               url3,\n               url4,\n               url5,\n               url6,\n               sep=\"\")\n\n  #pull the url, raw to char, parse json, grab articles element\n  rawResults &lt;- GET(url)\n  charResults &lt;- rawToChar(rawResults$content)\n  data &lt;- \n    charResults |&gt;\n    fromJSON() |&gt;\n    pluck(\"articles\")\n  \n  return(data)\n    \n}\n\nCalling it twice to collect some data. First on Mark Robinson, then on Wilmington NC.\n\ndata1 &lt;- queryNewsAPI('mark+robinson','2024-10-08','00cc83504de747bbb211235233c86424')\ndata2 &lt;- queryNewsAPI('wilmington+nc','2024-10-08','00cc83504de747bbb211235233c86424')\n\n\n\n\nHere, we want a one-way contingency table (counts) of the name of the source for each article. This is easy with the table() function used in HW5.\n\ntable(data1$source$name)\n\n\n                [Removed]            Aftonbladet.se        Al Jazeera English \n                        8                         1                         1 \n                 BBC News           Bleacher Report        Bleeding Cool News \n                        1                         1                         2 \n            Boston Herald            Breitbart News    CBM (Comic Book Movie) \n                        2                         1                         1 \n               CBS Sports               Cineblog.it              CounterPunch \n                       19                         2                         1 \n              Cracked.com                  Deadline          Dianeravitch.net \n                        1                         2                         2 \n                Dnyuz.com         Durham Herald Sun                     Eater \n                        1                         1                         1 \n                     ESPN              Fast Company                    Forbes \n                        5                         1                         6 \n               Fox Sports                  GameSpot                 Ifanr.com \n                        2                         1                         1 \n               Lithub.com                  Mediaite           Memeorandum.com \n                        1                         2                         2 \n             MMA Fighting                 MMA Mania                     MSNBC \n                        1                         3                         2 \n            NBCSports.com Nbcsportsphiladelphia.com                  Newsweek \n                        3                         1                         3 \n            Observador.pt         Politicalwire.com                 Raw Story \n                        1                         1                         2 \n                SB Nation               Screen Rant              Stanford.edu \n                        1                         3                         1 \n             The Atlantic                   TheWrap                      Time \n                        1                         1                         1 \n                 Truthout              Wonkette.com       Worldsoccertalk.com \n                        1                         1                         1 \n      Yahoo Entertainment \n                        3 \n\n\n\n\n\nFor both data objects, change publishedAt column into a date column via lubridate.\nThen sort the data frames by their new parsed date column.\nFinally, create a new column pub_diff via lag() and mutate() that is the difference between publish dates. Save the modified versions as new data frames.\n\nnewdata1 &lt;- \n  data1 |&gt;\n  mutate(publishedAt = ymd_hms(publishedAt)) |&gt;\n  arrange(publishedAt) |&gt;\n  mutate(pub_diff = publishedAt - dplyr::lag(publishedAt,1)) |&gt;\n  as.data.frame()\n\nnewdata2 &lt;- \n  data2 |&gt;\n  mutate(publishedAt = ymd_hms(publishedAt)) |&gt;\n  arrange(publishedAt) |&gt;\n  mutate(pub_diff = publishedAt - dplyr::lag(publishedAt,1)) |&gt;\n  as.data.frame()\n\n\n\n\nChoose one df, subset to return only date version of publishedAt and pub_diff.\nCall map() for mean, sd, median of the columns. Use an anonymous function. Note that pub_diff will have NA so ensure we add na.rm=TRUE in calls.\n\nfinaldata &lt;-\n  newdata2[c(\"publishedAt\",\"pub_diff\")] |&gt;\n  map(\\(x) \n    paste(\"mean:\",\n          mean(x,na.rm=TRUE),\n          \"sd:\",\n          sd(x,na.rm=TRUE),\n          \"median:\",\n          median(x,na.rm=TRUE)))\n   \nfinaldata \n\n$publishedAt\n[1] \"mean: 2024-10-10 14:35:10.625 sd: 201929.864707624 median: 2024-10-10 07:03:28.5\"\n\n$pub_diff\n[1] \"mean: 1333.22619047619 sd: 1105.48763992358 median: 1607.71666666667\""
  }
]